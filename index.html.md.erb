---
breadcrumb: Pivotal CF Documentation
title: Packaging Pivotal One Products
---

This document is intended for product teams to learn how to package, distribute, and upgrade Pivotal One products across releases.

Important: Packaging custom products is an alpha feature supported through a Pivotal Professional Services engagement or as part of an Enterprise License Agreement.

## <a id='assumptions'></a>Assumptions ##

This document might be difficult to follow unless you have a fully functional BOSH release of your product including a working manifest, release, and stemcell. You should also have a working knowledge of Pivotal Ops Manager and know, for example, what terms such as "resources page" or "product tile" refer to.

## <a id='opsmanager'></a> What is Ops Manager? ##

Pivotal Ops Manager is visual interface for installing and upgrading distributed software in the cloud. It is a vSphere Virtual Appliance that launches a Ruby on Rails application and orchestrates Pivotal's BOSH platform to manage virtual machines on vSphere. As of this writing, it can install Cloud Foundry, MySQL, Rabbit MQ, Pivotal HD, and any other product that has been packaged as a BOSH release.

## <a id='package'></a> How should a product be packaged? ##

The Ops Manager team refers to a packaged product as a "product zip" because it is archived using .zip format. The extension, however, should be .pivotal, to prevent users from extracting the .zip. Be sure to create and distribute an archive that uses the final release files of your product, and not development files.

The contents of the archive are the top-level directories listed below.

<p class='note'><strong>Note</strong>: Creating a product zip from folders as subdirectories of other folders is not supported.</p>

### <a id='releases'></a> Product Package - Releases Directory ###

The releases directory contains your product's release file. This is created using the BOSH command `bosh create release --with-tarball`. Multiple releases can be specified.

### <a id='template'></a> Product Package - Product Templates ###

The metadata directory contains a yaml file, named whatever you wish, with the product template that Ops Manager needs to prompt the user and do an install. This product template references your release and stemcell, creates the user input forms, and generates a BOSH manifest when a user clicks Apply Changes or Install in Ops Manager.

To understand how to author product templates / metadata, let's look at an example and explain the elements of interest.

```

---
name: p-redis                                              # [1]
product_version: 1.0.0.6                                   # [1]
metadata_version: "1.4"                                    # [2]
stemcell_criteria:                                         # [3]
  os:           ubuntu-trusty
  requires_cpi: false
  version:      "2858"
releases:                                                  # [5]
  - name:    redis
    file:    redis-0.2-dev.tgz
    version: 0.2-dev
  - name: redis-errands-release
    file: redis-errands-release-0.16-dev.tgz
    version: 0.16-dev
label: Redis
description: Redis is a key-value store that ...
icon_image: iVBORw0KGgoAAAANSUhEUgAAAG                     # [6]
rank: 1
post_deploy_errands:
- name: test-redis                                         # [7]

form_types:                                                # [8]
  - name: Redis
    label: Redis
    description: This is my little Redis
    property_inputs:                                       # [9]
      - reference: redis.password

  - name: redis_snapshotting_collection                    # [10]
      label: Snapshotting
      description: Create a snapshotting policy
      property_inputs:
        - reference: .snapshots
          label: Snapshots
          description: Enter the seconds and number of changes for each snapshot
          property_inputs:
            - reference: seconds
              label: Seconds
              description: Number of seconds before a save occurs
            - reference: changes
              label: Changes
              description: Number of changes to save in the elapsed seconds

property_blueprints:                                       # [10a]
  - name: snapshots
    type: collection
    configurable: true
    optional: false
    property_blueprints:
      - name: seconds
        type: integer
      - name: changes
        type: integer

job_types:                                                 # [11]
  - name: redis
    resource_label: redis label for resource page
    job_templates:
      - redis
    release: redis

    resource_definitions:                                  # [12]
      - name: ram
        type: integer
        configurable: true
        default: 1024

      - name: ephemeral_disk
        type: integer
        configurable: true
        default: 2048

      - name: persistent_disk
        type: integer
        configurable: true
        default: 3072

      - name: cpu
        type: integer
        configurable: true                                 # [13]
        default: 1

    static_ip: 0                                           # [14]
    dynamic_ip: 1
    max_in_flight: 1                                       # [15]
    serial: false                                          # [16]

    instance_definitions:
      - name: instances
        type: integer
        configurable: true
        default: 1

    property_blueprints:                                   # [17]
      - name: vm_credentials
        type: salted_credentials
        default:
          identity: vcap
     - name: password
        type: secret
        configurable: true
        optional: true                                     # [18]

    manifest: |                                            # [19]
      redis.password: (( password.value ))
      redis.snapshots: (( .properties.snapshots.value ))

  - name: test-redis
    resource_label: Test Redis
    job_templates:
      - test-redis
    release: redis-errands-release
    errand: true                                           # [20]
    resource_definitions:
    - name: ram
      type: integer
      configurable: true
      default: 1024
      constraints:
        min: 1024
    - name: ephemeral_disk
      type: integer
      configurable: true
      default: 1024
      constraints:
        min: 1024
    - name: persistent_disk
      type: integer
      configurable: false
      default: 0
    - name: cpu
      type: integer
      configurable: true
      default: 1
      constraints:
        min: 1
    static_ip: 0
    dynamic_ip: 1
    max_in_flight: 1
    instance_definitions:
    - name: instances
      type: integer
      configurable: false
      default: 1
    property_blueprints:
    - name: vm_credentials
      type: salted_credentials
      default:
        identity: vcap

  - name: compilation
    resource_label: compilation

    resource_definitions:
      - name: ram
        type: integer
        configurable: true
        default: 1_024

      - name: ephemeral_disk
        type: integer
        configurable: true
        default: 2_048

      - name: persistent_disk
        type: integer
        configurable: true
        default: 8_192

      - name: cpu
        type: integer
        configurable: true
        default: 1

    static_ip: 0
    dynamic_ip: 1
    max_in_flight: 1

    instance_definitions:
      - name: instances
        type: integer
        default: 1
```

1. name and product\_version: These uniquely identify a product. Ops Manager allows "upgrades" between products with the same name in the metadata, and different product\_versions.
2. metadata\_version: Every release of Ops manager expects a certain metadata schema. We are currently at 1.4.
3. stemcell_criteria: refers to the desired stemcell.
5. releases: An array of releases. BOSH Errand releases can be referred to here.
6. icon_image: A base64 encoded version of the logo for your image.
7. post\_deploy\_errands: An array of BOSH errands that run after a successful deployment. The name of the errand must correspond with the job.
8. form\_types: Each form that is displayed for user input is generated from a form type.
9. property\_input: An HTML input for a form is a reference to a property\_blueprint on a job\_type (see below).
10. Collections. A collection is a data structure containing multiple property inputs, a bit like a database table. When rendered as HTML the collection will display add, edit, and delete indicators. A user can create many records in a collection.<br /></br />
    Note that the `reference: .snapshots` key-value pair in the property\_inputs
	section of the redis\_snapshotting\_collection references [10a], a global
	property\_blueprints section.
	This property\_blueprints section describes the global .snapshots collection
	property, and not the property\_blueprints on a job\_type.

11. job\_types: A list of the jobs that correspond with the job names in your BOSH manifest.
12. resource_definitions: These are the sections that create the sizing table in Ops Manager's resource page. Note: CPU must be a power of 2.
13. configurable: Must be true for user to edit, otherwise it is disabled in the table or form.
14. static\_ip / dynamic\_ip: Corresponds to the BOSH setting for a job's IP allocation. If static\_ip is 0, dynamic\_ip must be 1 and vice versa. You should try and use dynamic\_ip when possible.
15. max\_in\_flight: Can be either a number or a ratio marked by a '%' percentage symbol.
16. serial: true/false. If false this job will be deployed in parallel with other jobs.
17. property\_blueprints: There are two kinds of blueprints. Property blueprints, their settings, types and defaults are further explored in the Types section.
18. optional: true/false. true means the value can be nil/blank. Defaults to false if this key is not specified.
19. manifest: Properties that you need to put in your BOSH manifest, underneath the appropriate job, are created here. This is how the form\_type's value is passed to the manifest (see example to the left). For more information on passing variables as property values, refer to the Manifest section.
20. errand: Optional. true/false. Set to true to run this job as an errand. This must correspond to the post\_deploy\_errand listed in #7 above. For more information about errands, see [Understanding Lifecycle Errands](./lifecycle-errands.html).

## <a id="blueprints"></a> More on Product Templates - Property Blueprints ##

Specifying the type of a property blueprint determines how the field shows up in the UI. It also determines what validation gets done when the user submits a form. Certain types have special features, e.g. you can specify min/max constraints for integer types, and you can have the various credential types be auto-generated.

For a type to show up in the UI it must be configurable.

For each type, one or many accessors will be defined below. It will be clear how to use these types when we look at manifest snippets.

### string

Accessor: value
Rendered Content: text input

### integer

Allows you to additionally specify constraints as follows:

```
name: my-prop
type: integer
label: Foo
constraints:
  min: 200
  max: 300
  power_of_two: true
```

You don't need to specify constraints, and if you do, you can specify either min, or max, or both. The power\_of\_two constraint should be used for the cpu resource definition for products deployed on VMware vSphere or vCloud Air / vCloud.

Accessor: value
Rendered Content: text input

### boolean

True/False value

Accessor: value
Rendered Content: checkbox

### dropdown

```
- name: favorite_color
  type: dropdown_select
  label: Favorite Color
  configurable: true
  default: red
  options:
    - name: red
      label: Red
    - name: navy_blue
      label: Navy Blue
```

Accessor: value
Rendered Content: Dropdown list of the options

### domain

Accessor: value
Rendered Content: text input

### wildcard_domain

For use with a WildcardDomainVerifier.

Accessor: value
Rendered Content: text input

### uuid

Accessor: value
Rendered Content: Not available
Generates: UUID

### string_list

Takes a comma delimited list of strings. The value is an array of non-empty strings from the input.

Accessor: value
Rendered Content: text input

### text

Accessor: value
Rendered Content: textarea

### selector

Allows for different sets of property blueprints and manifest templates based on user selection.

```yaml
property_blueprints:
  - name: selector_example
    type: selector
    configurable: true
    default: Not Configured
    option_templates:
      - name: not_configured
        select_value: Not Configured
        named_manifests:
          - name: my_snippet
            manifest: |
              is_this_configured: no
      - name: custom_configuration
        select_value: External DB
        named_manifests:
          - name: my_snippet
            manifest: |
              is_this_configured: yes
              configured_property: (( .properties.selector_example.custom_configuration.your_name.value ))
        property_blueprints:
          - name: your_name
            type: string
            configurable: true
```

Accessors:
  value: The select_value for the selected option
  selected_option: Allows you to retrieve a parsed manifest snippet for the selected option
  NAMED_OPTION: Provides access to the property blueprints for a named option
Rendered Content: Radio buttons that show the nested property blueprints for the selected option.

Example for the accessors:

```yaml
job_types:
  - name: example_selector_usage
    manifest: |
      custom_configured_name: (( .properties.selector_example.custom_configuration.your_name.value ))
      selected_option_manifest: (( .properties.selector_example.selected_option.parsed_manifest(my_snippet) ))
```

### ldap_url

Valid LDAP URI

Accessor: value
Rendered Content: text input

### collection

A collection of entries. Each entry has all of the nested properties.

```yaml
property_blueprints:
  - name: collection_example
    type: collection
    configurable: true
    optional: false
    property_blueprints:
      - name: first_nested_property
        type: string
      - name: second_nested_property
        type: string
```

Accessor: value
Rendered Content: An add button that provides a form to enter nested property values. A list component that allows editing and removing existing entries.

### email

Validates that it is an email address

Accessor: value
Rendered Content: text input

### http\_url

Full URL with http or https protocol

Accessors: value
Rendered Content: text input

### ip\_address

Validates a single IPv4 address

Accessor: value
Rendered Content: text input

### ip\_ranges

Comma-separated list of single IPv4 addresses and/or IPv4 ranges of the form 1.2.3.4-1.2.3.200

Accessor: value, parsed\_ip\_ranges (array)
Rendered Content: text input

### multi\_select\_options

When giving a property definition this type, you must also specify a list of options as follows:

```
name: my-prop
type: multi_select_options
label: Foo
options:
  - name: checkbox1
    label: Checkbox 1
  - name: checkbox2
    label: Checkbox 2 -
    name: checkbox3
    label: Checkbox 3
```

Accessor: value (array of selected option names)
Rendered Content: checkbox(es)

### network\_address\_list

Comma separated list of network addresses

Accessor: value, parsed\_network\_addresses (array)
Rendered Content: text input

### network\_address

IP address, domain, or single host-name. Renders as a text field.

Accessor: value
Rendered Content: text input

### port

Integer between 0 and 65535.

Accessor: value
Rendered Content: text input

### rsa\_cert\_credentials

A triple of private key, cert, and csr.

Accessors: public\_key\_pem, cert\_and\_private\_key\_pems
Rendered Content: textarea fields for the private key and cert
Generates: valid RSA private key, CSR, self-signed cert. All in PEM format.

### rsa\_pkey\_credentials

RSA private key

Accessors: public\_key\_pem, private\_key\_pem
Rendered Content: Not available
Generates: valid RSA private key

### salted\_credentials

A triple of identity, password, and salt.

Accessors: sha512\_hashed\_password, identity, salt, password
Rendered Content: Not available
Generates: identity, salt, password

### simple\_credentials

A pair of identity and password.

Accessors: identity, password
Rendered Content: text input for identity and password input for password
Generates: identity, password

### secret

Accessor: secret
Rendered Content: password input
Generates: secret

### smtp\_authentication

Authentication type for SMTP

Accessor: value
Rendered Content: dropdown where you can select from 'plain', 'login', and 'cram\_md5'

##  <a id='opsmanager_accessors'></a> Ops Manager provided accessors

These accessors are available within a job's manifest by using double paren notation.

Example usage:

```yaml
job_types:
  - name: first_job
    manifest: |
      my_first_ip: (( first_ip ))
      other_job_ip: (( .second_job.first_ip ))
  - name: second_job
```

### Available accessors

`availability_zone` : The availibility zone of the job instance

`ephemeral_disk` : The size of the ephemeral disk attached to the job's VM, given in megabytes

`first_ip` : The first ip assigned to the job

`instances` : The number of job instances

`ips` : An array of ips that the job has been assigned to

`ips_by_availability_zone` : Provides a hash. The keys are the identifiers for the different availability zones. The value is an array of ips assigned to the job for that availability zone.

`name` : Name of the job

`persistent_disk` : The size of the persistent disk attached to the job's VM, given in megabytes

`ram` : The RAM assigned to the job in megabytes

## <a id='vm_credentials'></a> VM Credentials

The vm_credentials property is **required** to be present on a job's property blueprints array. These are the credentials given to the created job VM.

```yaml
job_types:
  - name: my_job
    property_blueprints:
      - name: vm_credentials
        type: salted_credentials
        label: VM credentials
        configurable: false
        default:
          identity: vcap
```

## <a id='manifest'></a> More on Product Templates - Manifest

When a user clicks the Install or Apply Changes buttons in Ops Manager, a BOSH deployment manifest is generated and a BOSH deploy begins.

A BOSH manifest includes a number of properties for each job. These come from the job\_types in your product template, but the values the user entered are evaluated from the accessors listed in the table above. You can also create properties using the manifest section of your product template, which is most common for things that are neither entered by the user nor auto-generated.

To refer to things that were either entered by a user, or auto generated, you can use a special reference syntax, which the Ops Manager team refers to as "spiff syntax." Note that this is not the same as the spiff command line tool many of the other teams are using to generate manifests, it simply has a syntax that looks vaguely like spiff syntax.  You can also use Ruby's ERB syntax, but requires you to know something about the evaluation context and Ops Manager's internal object graph. It is not recommended that anyone use ERB.

Double parens will allow you to reference properties and job attributes.

```

job_types:
  - name: other_job
    property_blueprints:
      - name: creds
        type: simple_credentials
  - name: foo
    property_blueprints:
      - name: bar
        type: simple_credentials
        configurable: true
      - name: baz
        type: integer
        configurable: true
    manifest: |
      something:
        something_else: (( bar.identity )) # this access the identity access on the "bar"
       # property on this job (namely "foo")
        blah: (( bar.password ))
        hi: (( baz.value ))
      networkstuff:
        my_ip: (( first_ip ))           # this access the first IP allocated to this job
        bobs_ip: (( .other_job.first_ip ))  # the leading . means to go up a level and find
                        # a different job in this metadata, namely
                        # "other_job", and then ask it for things such as
                        # first_ip or an accessor on some property
        bobs_password: (( .other_job.creds.password ))
      stuff_i_need_from_other_deployment:
        runtime_uaa_ip: (( ..cf.uaa.first_ip )) # two leading .. means to go up two levels and
                             # find a different product, namely "cf"
```

## <a id='dependecies'></a> More about Product Templates - Dependency Management

If your product relies on other products, or you have specific jobs that rely on other products, you need to specify this in your product template. By creating a dependency, you will be warning users that they must meet prerequisites before installing. If the dependency is at a job level, and the user sets the number of instances to '0', there will be no dependency enforced.

Service brokers are a great example of why dependencies could be set at the job level. Service brokers have no purpose other than being used with Elastic Runtime, and they are tied to specific releases of the Cloud Controller. By setting dependency in the broker, and setting the number of instances to zero, a user could use the service independently without having to worry about it functioning with Elastic Runtime.

You should specify provides\_product\_version in your product template, even though it appears somewhat redundant as "name" and "product\_version" capture the same information. Additionally, you may use requires\_product\_versions to depend on something else.  This can be specified at the top-level of a product template, implying the entire product depends on another one; or it can be specified at an individual job\_type level.

Here's how this looks in Elastic Runtime's product template:

```
---
name: cf
product_version: 1.0.0.1
metadata_version: "1.1"
stemcell_criteria:
  os: ubuntu-trusty
  version: "2858"
  requires_cpi: false
releases:
  - name: cf
    version: "147.20-dev"
    file: cf-147.20-dev.tgz
    md5: 6b36ae7d613e5857447d789717f598ce
provides_product_versions:
  - name: cf
    version: 1.0.0.1
requires_product_versions:
  - name: microbosh
    version: "~> 1.0"
```

Here's how to create dependencies by job:

```
job_types:
  - name: database-server
    label: My DB Server
    resource_label: My DB Server
    description: Multi-tenant DB server
    job_templates:
      - db-server
    requires_product_versions:
      - name: cf
        version: "~> 1.0"
```

## <a id='migrations'></a>Product Package - content\_migrations directory ##

The content migrations directory contains yaml files that migrate installation data for products they previously installed. As of this writing we are within the 1.x.x.x release cycle, and thus all previously released product installations should be able to be migrated to the next. If you change the product template structure, like add, edit, or delete a job\_type, or property\_blueprint, you will need to create a content\_migration so that the customer's installation can migrate to these new settings.

## <a id='upgrades'></a>How are Upgrades Packaged? ##

When your team has a new release you must create a content migration. These migrations are yaml files with certain rules for updating the installation hash discussed in the previous section. This transformation uses a Ruby gem called Transmogrifier. The migration file must be placed in the content\_migrations directory in the product zip.

### Migrating the Product Version

The first, and simplest, value that must be migrated is the product version. Say, for example, that your last release is 1.0.0.3 and you are going to release version 2.0.0.0 next week. Your last version's product template looks like this:

```yaml
---
name: p-redis
product_version: 1.0.0.3
metadata_version: "1.1"
```

A content_migration yaml to migrate this version to the new 2.0.0.0 release would look like this:

```
product: redis
installation_version: "1.1"
to_version: "2.0.0.0"

migrations:
  - from_version: 1.0.0.3
    rules:
      - type: update
        selector: "product_version"
        to: "2.0.0.0"
```

Note: installation\_version is the schema version of the installation.yml file, which contains an installation's state. This is not the same as the metadata version, which refers to the schema of the product template that you are authoring.

If your customers have a couple of Redis versions released you can migrate more than one version with the same migration as follows:

```yaml
product: redis
installation_version: "1.1"
to_version: "2.0.0.0"

migrations:
  - from_version: 1.0.0.3
    rules:
      - type: update
        selector: "product_version"
        to: "2.0.0.0"
  - from_version: 1.0.0.4
    rules:
      - type: update
        selector: "product_version"
        to: "2.0.0.0"
```

### Migrating Property Names and Types

The example above, in which you modified a version number, uses the update type of migration. You can also use create and delete.

### Example 1. Adding a New Property

Imagine that your 2.0.0.0 Redis release has a new property called max\_memory. In this case, all you need to do is add this property to your product template so that Ops Manager will display it and set it in any new installation BOSH manifests. You do not need a content\_migration since the new installation file will be created when you click Apply Changes.

```yaml
    property_blueprints:
...
      - name: max_memory
        type: string
        label: max memory
        description: Enter the Max Memory for the Redis Cache
        configurable: true
    default: "2mb"

    manifest: |
      redis.password: (( credentials.password ))
      redis.max_memory: (( max_memory.value ))
```

### Example 2. Updating a Property Names

Redis uses admin passwords, without user names. Our original product template has a property called credentials that uses a simple\_credentials type. Unfortunately there was no simple\_password type which just prompts for password (there will be soon). To refresh your memory:

```yaml
     property_blueprints:
...
      - name: credentials
        type: simple_credentials
        label: credentials
        description: it is a secret
        configurable: true

    manifest: |
      redis.password: (( credentials.password ))

```

Imagine the new type called simple\_password was already available in Ops Manager. What would the steps be to migrate our password to this type?
First, we would need to modify our product template to the different type, give it a new name, and reference it by that name. Our new product template would look like this:

```yaml
     property_blueprints:
...
      - name: redis_password # NEW NAME (was called 'credentials')
        type: simple_password # NEW TYPE!
        label: redis password
        description: it is a secret
        configurable: true

    manifest: |
      redis.password: (( redis_password.password )) # NEW REFERENCE!
```

Next, we would look at our installation file and see if there are things to migrate:

```yaml
 - definition: credentials # Hmmm.. this uses the old name!
      value:
        identity: matt # We don't need this, Redis never used it anyhow...
        password: reider
```

Our Migration needs to change the name of property definition from credentials to redis\_password it would also be cleaner to delete the identity property as well.

Our complete migration file is as follows:

```yaml
---
product: redis
installation_version: "1.1"
to_version: "2.0.0.0"

migrations:
  - product_version: 1.0.0.3
    rules:
      - type: update
        selector: "product_version"
        to: "2.0.0.0"
      - type: update
        selector: jobs.[type=redis].properties.[definition=credentials]
        to: redis_password
      - type: delete
        selector: jobs.[type=redis].properties.[definition=credentials].value.identity
```

## <a id='verifier'></a>Verifiers ##

Product templates include two types of verifiers: form verifiers and install time verifiers. Most verifiers are built to check availability of resources and IP addresses or existence of network endpoints. If your product requires some kind of verifier, let the team know so we can build it. Verifiers are not shown in the product template sections earlier in this document.

### Form Verifiers

Form verifiers run when a user saves a form. You name the verifier in the form\_type section, under the name of the form. The following verifier checks that Elastic Runtime's router IP is free / available:

```yaml
  - name: router
    label: Router IPs
    description: "Enter the IP address(es) for the Cloud Foundry Router."
    verifier:
      name: Verifiers::StaticIpsVerifier
    property_inputs:
      - reference: router.static_ips
```

### Install Time Verifier Example

Install time verifiers run when a user clicks the Apply Changes or Install buttons. Usually you will run the same verifiers at install or form save, but they are broken out in case there are exceptions.

Here is an excerpt from the Elastic Runtime product template that verifies that the SSO Appliance, and SMTP servers, are available at the addresses the user entered:

```yaml
install_time_verifiers:
  - name: Verifiers::SsoUrlVerifier
    properties:
      url: saml_login.sso_url
  - name: Verifiers::SmtpAuthenticationVerifier
    properties:
      credentials: consoledb.smtp_credentials
      address: consoledb.smtp_address
      port: consoledb.smtp_port
      helo_domain: consoledb.smtp_helo_domain
      authentication: consoledb.smtp_authentication
      enable_starttls_auto: consoledb.smtp_enable_starttls_auto
```

### Verifier Definitions

Parameters are key pair values where the value is property reference whose type matches that of the parameter.

```
Name: Verifiers::LDAPBindVerifier
Parameters:
- url: ldap_url
- credentials: simple_credentials

Name: Verifiers::SmtpAuthenticationVerifier
Parameters:
- credentials: simple_credentials
- address: network_address
- port: integer
- helo_domain: domain
- authentication: smtp_authentication
- enable_starttls_auto: boolean

Name: Verifiers::SsoUrlVerifier
Parameters:
- url: http_url

Name: Verifiers::WildcardDomainVerifier
Parameters:
- domain: wildcard_domain

Name: Verifiers::StaticIpsVerifier
Parameters: none

Name: Verifiers::MysqlDatabaseVerifier
Parameters:
- host: network_address or string
- port: port
- username: string
- password: string or secret
- database: string

Name: Verifiers::BlobstoreVerifier
Parameters:
- access_key_id: string
- secret_access_key: string or secret
- bucket_name: string
```

## <a id='tips'></a> Tips and Tricks for Metadata Authors ##

Authoring product templates currently lacks tooling and is not for the faint of heart. If you find that your product template leads to 500 errors in the Ops Manager, you should start by validating that it can be parsed.

### Checking your YAML

```
$ gem install psych
$ irb
> require 'psych'
> contents = File.read('p-hd-tempest.yml')
> Psych.load(contents)
```

If you get an error, such as "Psych::SyntaxError: mapping values are not allowed in this context at line 24" it means there is likely a problem with spacing, or formatting, at line 23 or 24 of your file.

### SSHing into Ops Manager / Shortening the Feedback Cycle

Product Teams have reported that the feedback cycle for product template changes is long. Changing your product template, uploading an entire product to Ops Manager, and watching it fail, can be frustrating. We are working to make this easier.

One way to shorten the feedback cycle is possible by SSHing into the Ops Manager VM (username = tempest, password is whatever you set when you deployed the .ova). Once in the Ops Manager VM, you can edit product templates directly at `/var/tempest/meta-data`.

After editing metadata, you must restart the Ops Manager web application.

```
$ sudo service tempest-web stop
$ sudo service tempest-web start
```

### Restoring Previous Installation File

There is an undocumented feature in Ops Manager to restore the previous version of the installation file's state, including all Stemcells and Releases that were part of that installation file. This should not be confused with restoring the installation (VMs) itself. To restore an installation's state browse to https://{your ops manager}/restore

### Starting Fresh

If your installation file seems corrupted for some reason, and you want to start over again without installing a new .ova, you can go into vCenter, kill any deployed VMs, and then clean all of the files from the directory `/var/tempest/workspace`.

### Using the Ops Manager API

Using CURL, it is possible to automate most of the actions possible via the Ops Manager web interface. To view the Ops Manager API documentation, visit `https://{Ops Manager}/docs`.

<p class="note"><strong>Warning</strong>: The Ops Manager API is an experimental feature that is not fully implemented and could change without notice. Pivotal is developing an officially supported Ops Manager API that will replace many of these endpoints in a subsequent release.</p>

### Automating Ops Manager deployment

You can automate the deployment of an Ops Manager .ova to vSphere or vCloud Air / vCloud without using vCenter.

```
$ git clone git@github.com:pivotal-cf/installation.git
$ cd installation/gems/vsphere_clients
$ gem install vsphere_clients-*gem
$ cd ../ova_manager
$ gem install ova_manager-*gem
```

Once you have completed these steps you can write a script to both deploy an .ova as follows:

```ruby
require 'ova_manager'
require 'vsphere_clients'

OvaManager::Deployer.new({
  host: "172.16.74.3",
  user: "root",
  password: "vmware"
},{
  datacenter: "mozzarella-dc",
  cluster: "mozzarella-cl",
  datastore: "mozzarella-ds",
  network: "VM Network",
  folder: "Matt",
  resource_pool: ""
}).deploy("/Users/mreider/Downloads/z.ova", {
  ip: "172.16.74.150",
  netmask: "255.255.254.0",
  gateway: "172.16.74.1",
  dns: "10.80.130.1",
  ntp_servers: "10.80.130.1",
  vm_password: "admin"
})
```

The script to destroy an .ova looks like this:

```ruby
require 'ova_manager'
require 'vsphere_clients'

OvaManager::Destroyer.new("mozzarella-dc", {
    host: "172.16.74.3",
    user: "root",
    password: "vmware"
}).clean_folder("Matt")
```

## <a id='changes'></a> Changes from 1.3 to 1.4 ##

You can import your existing 1.3 product into a Ops Manager 1.4. To take adavantage of 1.4 features, you will need to update the following pieces of your metadata.

The following changes were made between version 1.3 released in November 2014 and 1.4 released in February 2015:


### metadata_version

The value should be 1.4

### icon_image

Old key: `image`
New key: `icon_image`

(128x128) format instead of the old image (163x110). The new icon should be centered with the product "label" text displayed centered underneath.

### stemcell

You should remove your stemcell in order for your product to be IaaS-agnostic. Remove your stemcell from the "stemcells" subdirectory within your product directory as shown in the image below:

<%= image_tag("remove-stemcell.png") %>

Your product template should refer to stemcells by only version and OS, as the following example shows:

<pre>
stemcell_criteria:
  os: ubuntu-trusty
  version: '2858'
  requires_cpi: false
</pre>

If you import or update a 1.3 product to Amazon Web Services (AWS), note the following:

* After importing, click **Import Stemcell** in Ops Manager to upload the referenced stemcell version, "xen-hvm," for AWS.
* If you update, your upload will contain unnecessary stemcell files that take up space.

### job_templates

The 'template' key under individual jobs has been renamed to 'job_templates'. Furthermore, it only supports an array as value.

### compiled_packages

Since compiled packages are a product of a infrastructure-specific stemcell and a release, compiled packages are no longer supported.

### New Ops Manager accessors

ips_by_availability_zone

Provides a hash. The keys are the identifiers for the different availability zones. The value is an array of ips assigned to the job for that availability zone.

```yaml
job_types:
  - name: first_job
    manifest: |
      my_ips_by_az: (( ips_by_availability_zone ))
```

Will be expanded to:

```yaml
job_types:
  - name: first_job
    manifest: |
      my_ips_by_az:
        zone1-guid: [192.168.1.100, 192.168.1.101]
        zone2-guid: [192.168.2.100]
```
